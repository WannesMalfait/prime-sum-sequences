use std::borrow::Cow;
use std::io;
use std::io::Write;
use std::thread;
use std::vec;

fn run() -> io::Result<()> {
    const MAX: usize = 10010;
    const START: usize = 10000;
    const DECREMENT: usize = 6;
    let primes = gen_primes_upto_n(2 * MAX - 1);
    println!("Primes are: {:?}", primes);
    let mat = Hankel::prime_sum_matrix(START, Some(&primes));
    let mut previous_path = mat
        .is_hamiltonian()
        .expect("No Hamiltonian cycle found for the starting index");
    // println!("{:?}", previous_path);
    let mut i = START;
    let mut start_indices = [0; (MAX - START) / 2 + 1];
    'outer: while i <= MAX {
        let mat = Hankel::prime_sum_matrix(i, Some(&primes));
        let mut start_index = i - DECREMENT;
        // We attempt to re-use the previous cycle
        while !mat.hamiltonian_cycle(&mut previous_path, start_index) {
            if start_index <= i - DECREMENT * 2 + 1 {
                println!("Trying from 0");
                if !mat.hamiltonian_cycle(&mut previous_path, 1) {
                    break 'outer;
                } else {
                    break;
                }
            }
            println!(
                "Failed with index {}, now trying with {}",
                start_index,
                start_index - DECREMENT + 1
            );
            start_index -= DECREMENT - 1;
        }
        if mat.valid_cycle(&previous_path) {
            println!("FOUND A VALID CYCLE OF LENGTH {}", i)
        } else {
            break;
        }
        start_indices[(i - START) / 2] = i - start_index;
        i += 2;
        previous_path.push(0);
        previous_path.push(0);
    }
    println!("Start indices: {:?}", start_indices);
    Ok(())
}
fn main() -> io::Result<()> {
    const STACK_SIZE: usize = 1024 * 1024 * 2;
    // Spawn thread with explicit stack size
    // Needed because of the heavy recursion
    let child = thread::Builder::new()
        .stack_size(STACK_SIZE)
        .spawn(run)
        .unwrap();

    // Wait for thread to join
    child.join().unwrap();
    Ok(())
}

/// A Hankel matrix is a matrix such that the entries along
/// a parallel to the main _anti-diagonal_ are equal. It
/// follows that the entries depend only on the sum i + j.
/// If i and j go from 0 to n - 1 we only need to store
/// 2n - 1 entries (i.e the first row and last column) to
/// have the full matrix.
///
/// # Example:
///
/// ```
/// 0 1 0 1 0 1
/// 1 0 1 0 1 0
/// 0 1 0 1 0 0
/// 1 0 1 0 0 0
/// 0 1 0 0 0 1
/// 1 0 0 0 1 0
/// ```
///
/// This is the 6 by 6 Hankel matrix generated by calling
///
/// ```
/// // The primes upto 2*6 - 1 = 11
/// let primes = vec![2,3,5,7,11];
/// let mat = Hankel::prime_sum_matrix(6, primes);
/// ```
struct Hankel {
    /// `diagonals` contains 2n-1 entries for an n by n matrix.
    diagonals: Vec<u8>,
    size: usize,
}

impl Hankel {
    fn new() -> Self {
        Hankel {
            diagonals: Vec::new(),
            size: 0,
        }
    }
    /// Generate the Hankel matrix for the prime sum sequences of order n.
    ///
    /// `primes` should be generated at least upto 2n + 1, because we need to check if
    /// n + (n - 1) is prime
    fn prime_sum_matrix(n: usize, primes: Option<&Vec<usize>>) -> Self {
        let mut diagonals = vec![0; 2 * n - 1];
        let mut i = 1; // index 0 is zero
        let p = match primes {
            Some(p) => Cow::Borrowed(p),
            None => Cow::Owned(gen_primes_upto_n(2 * n - 1)),
        };
        while i < 2 * n - 1 {
            if let Ok(_) = p.binary_search(&(i + 2)) {
                diagonals[i] = 1;
            }
            i += 2; // skip over the even numbers.
        }
        Self { diagonals, size: n }
    }
    /// Generate a Hankel matrix of size `n`by `n` from `values`
    /// Note that the rows and colums are 1-indexed, i.e the top
    /// left corner of the matrix is at index (1,1).
    fn from_sequence(n: usize, sequence: &Vec<usize>) -> Self {
        let mut diagonals = vec![0; 2 * n - 1];
        for i in 0..(2 * n - 1) {
            if let Ok(_) = sequence.binary_search(&(i + 2)) {
                diagonals[i] = 1;
            }
        }
        Self { diagonals, size: n }
    }
    /// Get the entry in the matrix at the specified
    /// `row` and `col`. The first row and collumn
    /// are 1, i.e. the indexing starts at 1.
    fn get(&self, row: usize, col: usize) -> u8 {
        // println!("1-indexed: row {} col {}", row, col);
        self.diagonals[row + col - 2]
    }
    /// Get the entry in the matrix at the specified
    /// `row` and `col`. The first row and collumn
    /// are 0, i.e. the indexing starts at 0.
    fn get_0_based(&self, row: usize, col: usize) -> u8 {
        // println!("0-indexed: row {} col {}", row, col);
        self.diagonals[row + col]
    }

    fn valid_path(&self, path: &Vec<usize>) -> bool {
        for i in 0..(path.len() - 1) {
            match self.get(path[i], path[i + 1]) {
                0 => return false,
                _ => continue,
            }
        }
        true
    }
    fn valid_cycle(&self, cycle: &Vec<usize>) -> bool {
        for i in 0..(cycle.len() - 1) {
            match self.get(cycle[i], cycle[i + 1]) {
                0 => return false,
                _ => continue,
            }
        }
        self.get(cycle[0], cycle[cycle.len() - 1]) != 0
    }
    /// If there is a cycle return it. Otherwise return None.
    fn is_hamiltonian(&self) -> Option<Vec<usize>> {
        let mut path = vec![0; self.size];
        path[0] = 1;
        if self.hamiltonian_cycle(&mut path, 1) {
            Some(path)
        } else {
            None
        }
    }
    fn hamiltonian_cycle(&self, path: &mut Vec<usize>, cur_length: usize) -> bool {
        if cur_length == self.size {
            // println!("cur length {}", cur_length);
            return self.get(path[0], path[cur_length - 1]) != 0;
        }
        // the sequence alternates between odd and even
        // loop backwards, because we are reusing the previously found cycles
        // which are all made up of smaller numbers
        let mut n = self.size - (cur_length + 1) % 2;
        'outer: while n > 1 {
            // println!("n {} cur_length {}", n, cur_length);
            if self.get(path[cur_length - 1], n) == 0 {
                n -= 2;
                continue;
            }
            // println!("n {}", n);
            let mut j = cur_length % 2;
            while j < cur_length {
                if path[j] == n {
                    n -= 2;
                    continue 'outer;
                }
                j += 2;
            }
            path[cur_length] = n;
            // println!("Path {:?}", path);
            if self.hamiltonian_cycle(path, cur_length + 1) {
                return true;
            }
            path[cur_length] = 0;
            n -= 2;
        }
        false
    }

    fn print(&self) -> io::Result<()> {
        let mut output = io::BufWriter::new(io::stdout());
        for row in 0..self.size {
            for col in 0..(self.size - 1) {
                write!(&mut output, "{}, ", self.get_0_based(row, col))?;
            }
            writeln!(&mut output, "{}", self.get_0_based(row, self.size - 1))?;
        }
        output.flush()?;
        Ok(())
    }
}

/// Generates the primes upto and including `n`. Doesn't
/// check for overflow on `n`
fn gen_primes_upto_n(n: usize) -> Vec<usize> {
    let mut primes = Vec::new();
    'outer: for i in 2..(n + 1) {
        for &prime in &primes {
            if i % prime == 0 {
                continue 'outer;
            }
        }
        primes.push(i);
    }
    primes
}

fn adjacency_mat(number: usize, primes: &Vec<usize>) -> Vec<Vec<usize>> {
    let mut matrix: Vec<Vec<usize>> = Vec::with_capacity(number);
    let mut first_row = Vec::with_capacity(number);
    first_row.push(0);
    // We fill the first row.
    for i in 1..number {
        match primes.binary_search(&(i + 2)) {
            Ok(_) => {
                first_row.push(1);
            }
            Err(_) => {
                first_row.push(0);
            }
        }
    }
    matrix.push(first_row);
    // If i and j form a pair then i+1 and j-1 as well
    // Therefore we only need to look at the last element in the
    // row
    for i in 1..number {
        let mut row = Vec::with_capacity(number);
        for j in 0..(number - 1) {
            row.push(matrix[i - 1][j + 1]);
        }
        match primes.binary_search(&(i + number + 1)) {
            Ok(_) => {
                row.push(1);
            }
            Err(_) => {
                row.push(0);
            }
        }

        matrix.push(row);
    }
    matrix
}

fn possible_inserts_in(sequence: &Vec<usize>, number: usize, primes: &Vec<usize>) -> Vec<usize> {
    let mut indices = Vec::new();
    let mut failed = -1;
    for i in 0..(sequence.len() - 1) {
        if let Ok(_) = primes.binary_search(&(sequence[i] + sequence[i + 1])) {
            continue;
        } else {
            if failed == -1 {
                // This is the first time the sum was not prime
                failed = i as isize;
            } else {
                // There are two spots where the sum is not prime
                // therefore we can't fix it with one insert.
                return indices;
            }
        }
    }
    if failed != -1 {
        // There is only one spot where the sum was not prime, test
        // if we can insert the number here to make it prime.
        // For this we need to check the number before and after.
        if let Ok(_) = primes.binary_search(&(sequence[failed as usize] + number)) {
            if let Ok(_) = primes.binary_search(&(sequence[failed as usize + 1] + number)) {
                // println!(
                //     "Not a prime sum sequence (one failed): {:?}, failed at {}, inserting {}",
                //     sequence, failed, number
                // );
                indices.push(failed as usize + 1); // insert adds the element such that it goes to that index
            }
        }
        return indices;
    }
    // println!("Prime sum sequence: {:?}", sequence);
    // The sequence is a prime sum sequence.
    // We now test at which indices we can insert
    let mut previous_was_ok = true;
    // ex: sequence 5 2 9 , number 6
    // 6+5=11 is prime so we add 0 to the indices
    // we now check if we can insert between 5 and 2
    // 6 + 2 = 8 is not prime so we can't insert between 5 and 2
    // this means we can't insert between 2 and 9 either.
    for i in 0..sequence.len() {
        // Is the sum prime?
        if let Ok(_) = primes.binary_search(&(sequence[i] + number)) {
            // Ok we can insert here
            if previous_was_ok {
                indices.push(i);
            }
            previous_was_ok = true;
        } else {
            {
                // We can't insert, but that means we can't insert in the next index either
                previous_was_ok = false;
            }
        }
    }
    // if the previous was ok we can append the num to the sequence,
    // the vector insert method does accept this as a valid index.
    if previous_was_ok {
        indices.push(sequence.len());
    }
    indices
}

/// Expects `n` to be at least two
fn primes_sum_sequences_of_lengths_upto_n(n: usize, primes: &Vec<usize>) -> Vec<Vec<Vec<usize>>> {
    let mut sequences = Vec::with_capacity(n);
    let mut permutations = vec![vec![1, 2]];
    let mut factorial: usize = 1; // We know the number of permutations
    sequences.push(vec![vec![1, 2]]);
    for i in 3..(n + 1) {
        let mut new_sequences = Vec::new();
        for permutation in &permutations {
            for index in possible_inserts_in(permutation, i, primes) {
                let mut new_sequence = permutation.clone();
                new_sequence.insert(index, i);
                new_sequences.push(new_sequence);
            }
        }
        sequences.push(new_sequences);
        factorial *= i;
        new_permutations(&mut permutations, i, factorial);
    }
    sequences
}
/// `n` should be at least 2
fn primes_sum_sequences_of_length_n(n: usize, primes: &Vec<usize>) -> Vec<Vec<usize>> {
    let mut sequences = Vec::with_capacity(n);
    let mut permutations = vec![vec![1, 2]];
    let mut factorial: usize = 1; // We know the number of permutations
    for i in 3..n {
        factorial *= i;
        new_permutations(&mut permutations, i, factorial);
    }
    for permutation in &permutations {
        for index in possible_inserts_in(permutation, n, primes) {
            let mut new_sequence = permutation.clone();
            new_sequence.insert(index, n);
            sequences.push(new_sequence);
        }
    }
    sequences
}

fn new_permutations(permutations: &mut Vec<Vec<usize>>, new_element: usize, size: usize) {
    let len = permutations.len();
    permutations.reserve_exact(size - len);
    for i in 0..len {
        for j in 0..(new_element - 2) {
            let mut new_perm = permutations[i].clone();
            new_perm.insert(j, new_element);
            permutations.push(new_perm);
        }
        permutations[i].insert(new_element - 1, new_element);
    }
}
