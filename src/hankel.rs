use std::borrow::Cow;
use std::io;
use std::io::Write;
use std::vec;

#[derive(Debug)]
/// A Hankel matrix is a matrix such that the entries along
/// a parallel to the main _anti-diagonal_ are equal. It
/// follows that the entries depend only on the sum i + j.
/// If i and j go from 0 to n - 1 we only need to store
/// 2n - 1 entries (i.e the first row and last column) to
/// have the full matrix.
///
/// # Example:
///
/// ```
/// 0 1 0 1 0 1
/// 1 0 1 0 1 0
/// 0 1 0 1 0 0
/// 1 0 1 0 0 0
/// 0 1 0 0 0 1
/// 1 0 0 0 1 0
/// ```
///
/// This is the 6 by 6 Hankel matrix generated by calling
///
/// ```
/// // The primes upto 2*6 - 1 = 11
/// let primes = vec![2,3,5,7,11];
/// let mat = Hankel::prime_sum_matrix(6, primes);
/// ```
pub struct Hankel {
    /// `diagonals` contains 2n-1 entries for an n by n matrix.
    diagonals: Vec<u8>,
    pub size: usize,
}

impl Hankel {
    /// Generate the Hankel matrix for the prime sum sequences of order n.
    ///
    /// `primes` should be generated at least upto 2n + 1, because we need to check if
    /// n + (n - 1) is prime
    pub fn prime_sum_matrix(n: usize, primes: Option<&Vec<usize>>) -> Self {
        let mut diagonals = vec![0; 2 * n - 1];
        let mut i = 1; // index 0 is zero
        let p = match primes {
            Some(p) => Cow::Borrowed(p),
            None => Cow::Owned(gen_primes_upto_n(2 * n - 1)),
        };
        while i < 2 * n - 1 {
            if let Ok(_) = p.binary_search(&(i + 2)) {
                diagonals[i] = 1;
            }
            i += 2; // skip over the even numbers.
        }
        Self { diagonals, size: n }
    }
    /// Generate a Hankel matrix of size `n`by `n` from `values`
    /// Note that the rows and colums are 1-indexed, i.e the top
    /// left corner of the matrix is at index (1,1).
    pub fn from_sequence(n: usize, sequence: &Vec<usize>) -> Self {
        let mut diagonals = vec![0; 2 * n - 1];
        for i in 0..(2 * n - 1) {
            if let Ok(_) = sequence.binary_search(&(i + 2)) {
                diagonals[i] = 1;
            }
        }
        Self { diagonals, size: n }
    }
    /// Get the entry in the matrix at the specified
    /// `row` and `col`. The first row and collumn
    /// are 1, i.e. the indexing starts at 1.
    pub fn get(&self, row: usize, col: usize) -> u8 {
        self.diagonals[row + col - 2]
    }
    /// Get the entry in the matrix at the specified
    /// `row` and `col`. The first row and collumn
    /// are 0, i.e. the indexing starts at 0.
    pub fn get_0_based(&self, row: usize, col: usize) -> u8 {
        self.diagonals[row + col]
    }
    /// Checks if `path` is a valid Hamiltonian path in
    /// the current graph.
    pub fn valid_path(&self, path: &Vec<usize>) -> bool {
        for i in 0..(path.len() - 1) {
            match self.get(path[i], path[i + 1]) {
                0 => return false,
                _ => continue,
            }
        }
        true
    }
    /// Checks if `cycle` is a valid Hamiltonian cycle in
    /// the current graph.
    pub fn valid_cycle(&self, cycle: &Vec<usize>) -> bool {
        for i in 0..(cycle.len() - 1) {
            match self.get(cycle[i], cycle[i + 1]) {
                0 => return false,
                _ => continue,
            }
        }
        self.get(cycle[0], cycle[cycle.len() - 1]) != 0
    }
    /// If there is a cycle return it. Otherwise return None.
    pub fn is_hamiltonian(&self) -> Option<Vec<usize>> {
        let mut path = vec![0; self.size];
        path[0] = 1;
        if self.hamiltonian_cycle(&mut path, 1) {
            Some(path)
        } else {
            None
        }
    }
    /// Tries to make a Hamiltonian cycle out of `path` using backtracking
    ///
    /// The values in the path before `pos` are left unchanged.
    /// Returns false if no cycle was constructed.
    pub fn hamiltonian_cycle(&self, path: &mut Vec<usize>, pos: usize) -> bool {
        if pos == self.size {
            // println!("cur length {}", cur_length);
            return self.get(path[0], path[pos - 1]) != 0;
        }
        // the sequence alternates between odd and even
        // loop backwards, because we are reusing the previously found cycles
        // which are all made up of smaller numbers
        let mut n = self.size - (pos + 1) % 2;
        'outer: while n > 1 {
            if self.get(path[pos - 1], n) == 0 {
                n -= 2;
                continue;
            }
            let mut j = pos % 2;
            while j < pos {
                if path[j] == n {
                    n -= 2;
                    continue 'outer;
                }
                j += 2;
            }
            path[pos] = n;
            if self.hamiltonian_cycle(path, pos + 1) {
                return true;
            }
            path[pos] = 0;
            n -= 2;
        }
        false
    }
    /// Prints the associated adjacency matrix to stdout.
    pub fn print(&self) -> io::Result<()> {
        let mut output = io::BufWriter::new(io::stdout());
        for row in 0..self.size {
            for col in 0..(self.size - 1) {
                write!(&mut output, "{}, ", self.get_0_based(row, col))?;
            }
            writeln!(&mut output, "{}", self.get_0_based(row, self.size - 1))?;
        }
        output.flush()?;
        Ok(())
    }
    /// Returns the degrees of all of the vertices in the graph.
    ///
    /// If the current `size` is n, then the returned vector has
    /// length n.
    ///
    /// The degrees are recalculated at every call.
    pub fn vertex_degrees(&self) -> Vec<usize> {
        let mut degrees = Vec::with_capacity(self.size);
        if self.size == 0 {
            return degrees;
        }
        let mut first = self.diagonals[0] as usize;
        let mut sum = first as usize;
        // Calculate the degree of the first vertex
        for i in 1..self.size {
            sum += self.diagonals[i] as usize;
        }
        degrees.push(sum);
        // The degree of the i-th vertex is the sum over the entries
        // in the diagonals array from i to i + n, where n is self.size
        // so if the diagonals array is something like:
        // [0,1,0,1,0,1,0,0,0,1,0]
        // then the degree of the vertices are:
        // 1st: 0+1+0+1+0+1 = 3
        // 2nd: 1+0+1+0+1+0 = 3
        // 3rd: 0+1+0+1+0+0 = 2
        // 4th: 1+0+1+0+0+0 = 2
        // 5th: 0+1+0+0+0+1 = 2
        // 6th: 1+0+0+0+1+0 = 2
        for i in self.size..self.diagonals.len() {
            sum += self.diagonals[i] as usize;
            sum -= first;
            first = self.diagonals[i - self.size + 1] as usize;
            degrees.push(sum);
        }
        degrees
    }
}

/// Generates the primes upto and including `n`. Doesn't
/// check for overflow on `n`
pub fn gen_primes_upto_n(n: usize) -> Vec<usize> {
    let mut primes = Vec::new();
    'outer: for i in 2..(n + 1) {
        for &prime in &primes {
            if i % prime == 0 {
                continue 'outer;
            }
        }
        primes.push(i);
    }
    primes
}
